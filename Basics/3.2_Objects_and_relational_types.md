### **Objects and Relational Data Types trong Elasticsearch**

Elasticsearch hỗ trợ nhiều kiểu dữ liệu để quản lý các **JSON object** và các mối quan hệ giữa dữ liệu. Những kiểu dữ liệu này được thiết kế để làm việc với các cấu trúc dữ liệu phức tạp hoặc mang tính quan hệ, như các đối tượng lồng nhau, dữ liệu phân cấp (hierarchical), hoặc mối quan hệ cha-con.

---

### **1. `object`**

#### **Mô tả**:

- `object` đại diện cho một **JSON object**.
- Các trường (field) bên trong `object` sẽ được **flattened** (phẳng hóa) thành các trường riêng biệt trong index.
- **Quan trọng**: Quan hệ giữa các trường con sẽ không được bảo toàn.

#### **Ví dụ**:

**Mapping:**

```json
PUT /example_index
{
  "mappings": {
    "properties": {
      "address": {
        "type": "object"
      }
    }
  }
}
```

**Document:**

```json
PUT /example_index/_doc/1
{
  "address": {
    "city": "New York",
    "zip": "10001"
  }
}
```

**Kết quả:**

- Elasticsearch sẽ lưu các trường `address.city` và `address.zip` dưới dạng **các trường phẳng (flattened)**.
- Bạn có thể truy vấn trực tiếp:
  ```json
  GET /example_index/_search
  {
    "query": {
      "term": {
        "address.city": "New York"
      }
    }
  }
  ```

---

### **2. `flattened`**

#### **Mô tả**:

- `flattened` lưu trữ **toàn bộ JSON object như một giá trị duy nhất**.
- Phù hợp khi bạn muốn lưu trữ các trường động hoặc không biết trước, nhưng không cần truy vấn các trường con.

#### **Ví dụ**:

**Mapping:**

```json
PUT /example_index
{
  "mappings": {
    "properties": {
      "metadata": {
        "type": "flattened"
      }
    }
  }
}
```

**Document:**

```json
PUT /example_index/_doc/1
{
  "metadata": {
    "key1": "value1",
    "key2": "value2"
  }
}
```

**Kết quả:**

- Toàn bộ `metadata` được lưu trữ như một giá trị duy nhất.
- Bạn có thể truy vấn cụ thể một key trong object:
  ```json
  GET /example_index/_search
  {
    "query": {
      "term": {
        "metadata.key1": "value1"
      }
    }
  }
  ```

---

### **3. `nested`**

#### **Mô tả**:

- `nested` lưu trữ JSON object nhưng bảo toàn **quan hệ giữa các trường con**.
- Các object lồng nhau sẽ được lưu trữ như các **document phụ (nested documents)**.
- Phù hợp với các mảng chứa các object phức hợp.

#### **Ví dụ**:

**Mapping:**

```json
PUT /example_index
{
  "mappings": {
    "properties": {
      "comments": {
        "type": "nested"
      }
    }
  }
}
```

**Document:**

```json
PUT /example_index/_doc/1
{
  "comments": [
    { "user": "Alice", "message": "Great post!" },
    { "user": "Bob", "message": "I agree!" }
  ]
}
```

**Kết quả:**

- Mỗi object trong mảng `comments` được lưu như một **document phụ**.
- Bạn có thể truy vấn cụ thể từng object:
  ```json
  GET /example_index/_search
  {
    "query": {
      "nested": {
        "path": "comments",
        "query": {
          "bool": {
            "must": [
              { "match": { "comments.user": "Alice" } },
              { "match": { "comments.message": "Great post!" } }
            ]
          }
        }
      }
    }
  }
  ```

---

### **4. `join`**

#### **Mô tả**:

- `join` định nghĩa **mối quan hệ cha-con** (parent-child) giữa các documents trong cùng một index.
- Phù hợp khi bạn muốn mô hình hóa **dữ liệu quan hệ** (relational data).

#### **Ví dụ**:

**Mapping:**

```json
PUT /example_index
{
  "mappings": {
    "properties": {
      "my_relation": {
        "type": "join",
        "relations": { "parent": "child" }
      }
    }
  }
}
```

**Documents:**

1. Thêm document cha:

   ```json
   PUT /example_index/_doc/1
   {
     "my_relation": "parent",
     "name": "Parent Document"
   }
   ```

2. Thêm document con:
   ```json
   PUT /example_index/_doc/2?routing=1
   {
     "my_relation": {
       "name": "child",
       "parent": "1"
     },
     "name": "Child Document"
   }
   ```

**Kết quả:**

- Document `2` là con của document `1`.
- Bạn có thể truy vấn dựa trên quan hệ cha-con:

  - **Tìm con theo cha:**

    ```json
    GET /example_index/_search
    {
      "query": {
        "has_parent": {
          "parent_type": "parent",
          "query": {
            "match": { "name": "Parent Document" }
          }
        }
      }
    }
    ```

  - **Tìm cha theo con:**
    ```json
    GET /example_index/_search
    {
      "query": {
        "has_child": {
          "type": "child",
          "query": {
            "match": { "name": "Child Document" }
          }
        }
      }
    }
    ```

---

### **5. `passthrough`**

#### **Mô tả**:

- `passthrough` tạo **aliases cho các trường con** ở cùng một cấp độ.
- Ít được sử dụng trong các trường hợp thông thường.

---

### **So sánh các kiểu dữ liệu**

| **Kiểu dữ liệu** | **Mô tả**                                                              | **Dùng khi nào**                                                           | **Hạn chế**                                       |
| ---------------- | ---------------------------------------------------------------------- | -------------------------------------------------------------------------- | ------------------------------------------------- |
| **`object`**     | JSON object. Các trường con được flatten thành các trường riêng biệt.  | Khi không cần bảo toàn quan hệ giữa các trường con.                        | Quan hệ giữa các trường con bị mất.               |
| **`flattened`**  | Lưu toàn bộ JSON object dưới dạng một giá trị duy nhất.                | Khi không cần truy vấn từng trường con hoặc cần lưu trữ dữ liệu động.      | Không thể tìm kiếm hoặc truy vấn từng trường con. |
| **`nested`**     | Lưu object như các nested documents, bảo toàn quan hệ giữa các trường. | Khi cần tìm kiếm hoặc lọc trên một object cụ thể trong một mảng đối tượng. | Tốn tài nguyên hơn so với `object`.               |
| **`join`**       | Mô hình hóa quan hệ cha-con giữa các documents.                        | Khi cần lưu trữ dữ liệu quan hệ mà không muốn tách thành nhiều index.      | Yêu cầu sử dụng routing và phức tạp hơn.          |

---

Nếu bạn cần thêm ví dụ hoặc giải thích sâu hơn, hãy cho tôi biết nhé!
